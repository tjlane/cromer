/* PROGRAM TO INTERPOLATE CROSS SECTIONS AND COMPUTE ANOMALOUS SCATTERING FACTORS */#include <math.h>#include <stdlib.h>#include <string.h>#include <ctype.h>#include <stdio.h>#include "get_fp.h"//#ifdef __MWERKS__#define	DATA	"XSECTDAT2X.BIN"		/* XSECTDAT2.BIN *///#else//#define	DATA	"../XSECTDAT2X.BIN"//#endif#define PI			3.141592653589793239#define PI2			9.869604401089359	/* PI^2 */#define AU			2.80022E+7#define MX			5					/* number of energies */#define C			137.0367#define C1			.02721#define	CACHE_LEN	100					/* was 40 */#define DELTA_XK	0.1e-3				/* for cache use delta E of 0.1 eV */#define MAX(a,b)	( (a>b) ? (a) : (b) )#define MIN(a,b)	( (a>b) ? (b) : (a) )static	double	cx,bb,sigg[6],rx,sedge;static	int		icount;void sort_fp(int n, double a[], double b[]);void	xsect(double zx,double el[15],double sl[15],double *cx, int nx);double	sigma0(double x);double	sigma1(double x);double	sigma2(double x);double	sigma3(double x);void	lgndr(int m, int k, double *aa,double *z);double	gauss(double (*y)());double	aknint(double xbar, int in, int im, double x[], double y[], double t[]);void	sort(int n, double a[], double b[]);fcomplex get_fp(char	atom_in[],	/* atomtype, atom symbol + ionization */double	H,			/* 2*¹/d */double	xk,			/* energy in KeV */int		nord,		/* order of interpolation [0,3] */float	*pmu		/* mu over rho (cm^2/g) */){/*     QUESTIONS CONCERNING THIS PROGRAM SHOULD BE ADDRESSED TO            DON T. CROMER   MST-5            MAIL STOP G730            LOS ALAMOS NATIONAL LABORATORY            LOS ALAMOS, NEW MEXICO 87545          INPUT     THREE CARDS ARE READ FROM FILE IN          1. natom(ATOMIC SYMBOL)          2  nord=INTERPOLATION TYPE(SEE BELOW).     nord=0 INTERPOLATION IS BY FITTING THREE CLOSEST POINTS            TO A QUADRATIC     nord=1,2,3 ETC. USE AITKEN'S INTERPOLATION METHOD AND nord          IS THE INTERPOLATION ORDER. nord=2 IS PROBABLY THE BEST          VALUE TO USE          3 HAS VALUE OF XRAY ENERGY     CROSS SECTION FILE IS READ FROM FILE IS. THIS COULD BE     THE SAME AS THE INPUT FILE.          *********NOTE********     FOR EACH ATOM FROM ATOMIC NUMBER 3-98     THE CROSS SECTION FILE WILL HAVE A NUMBER OF ORBITALS     THE FIRST MX CARDS (MX=5 FOR THIS XSECTION FILE AND IS SET IN PROGRAM)     FOR EACH ORBITAL WILL HAVE CROSS SECTIONS AT MX VALUES OF ENERGY     FROM ABOUT 1 TO 80 KEV APPROXIMATELY EQUALLY SPACED IN LOG(ENERGY)     THE NEXT FIVE RECORDS WILL BE CROSS SECTIONS AT ENERGIES SELECTED     BY GAUSS INTEGRATION SCHEME. IF THE FUNCTION TYPE IS 0 (IF=0)     ( FUNCTION TYPE GIVEN IN CROMER AND LIBERMAN         J. CHEM. PHYS. 53,1891-1898(1970)     )     A SIXTH VALUE IS READ IN FOR AN ENERGY=1.001*(BINDING ENERGY).     IF THE XRAY ENERGY IS LESS THAN BINDING ENERGY, FUNCTION sigma3     WILL BE USED (CROMER AND LIBERMAN ACTA CRYST. A37,267-268(1981))     FILES IN IO AND IS ARE SET AT THE BEGINNING OF THE PROGRAM     THESE WILL DEPEND ON LOCAL CONVENTIONS         ***********WARNING*************     IF AN XRAY ENERGY IS VERY CLOSE TO ONE OF THE ENERGIES     USED IN THE GAUSS INTEGRATION AN ANOMALOUS ANOMALOUS SCATTERING     FACTOR MAY RESULT. THERE IS NO EASY WAY OUT OF THIS PROBLEM. A     SUGGESTED WAY IS TO COMPUTE SEVERAL VALUES AT NEARBY ENERGIES     AND DRAW A SMOOTH CURVE. THIS METHOD SHOULD WORK PROVIDED     THE POINTS DO NOT PASS THROUGH AN EDGE*//*	double	sigma0();	double	sigma1();	double	sigma2();	double	sigma3(); */	fcomplex	fprime;		/* atomic form factor includes fo and Honl corrections */	FILE	*lun;			/* logical unit number for I/O */	double	fp[25],fpp[25];	double	ew[15],sig[15],el[15],sl[15];	double	T[81];		double	eg[6];	double	fo;				/* the structure factor */	double	zz;				/* compute simple Z electron point */	int		iz=0;			/* atomic number */	char	natom[3];		/* atomic symbol */	char	nat[3];	double	be;	double	sigedg;	double	zx;	double	cxb=0.;	double	corr;	double	sumfp,sumfpp;	double	xjensn;	double	et;	int		i,j,k,m;	int		n1,mm;	int		no;	long	nj;	long	IF;	int		nx;	int		mf;	size_t	c_byte;			/* size of atom name to write */	size_t	i_byte;			/* size of an integer */	size_t	sd_byte;		/* size of a double */	double	sd;				/* unsed for the fread */	static int	cache_init = 0;	/* flags whether the cache is initialized */	static struct cache_struct {		int		z;			/* equivalent to the atomic number iz */		int		hits;		/* number of hits on this cache item */		float	xk;			/* energy (keV) */		float	mu;			/* mu/rho */		fcomplex df;		/* stored value of Æf' +i Æf'' */	} cache[CACHE_LEN];	int		hits_min;		/* the minimum value of cache[i].hits */	int		i_hit_min;		/* the location in cache of hits_min */	double eterm[99] = { 0., .0,.0,.001,.001,.002,.003,.005,.007,.009, 			.011,.014,.018,.021,.026,.030,.035,.041,.047,.053,.060,.068, 			.075,.084,.093,.102,.113,.123,.135,.146,.159,.172,.186,.200, 			.215,.231,.247,.264,.282,.300,.319,.338,.359,.380,.401,.424, 			.447,.471,.496,.521,.547,.575,.602,.631,.660,.690,.721,.753, 			.786,.819,.854,.889,.925,.962,1.0,1.039,1.079,			1.119,1.161,1.204,1.248,1.293,1.338, 			1.385,1.433,1.482,1.532,1.583,1.636,1.689,1.743,1.799,1.856, 			1.914,1.973,2.033,2.095,2.157,2.221,2.287,2.353,2.421,2.490, 			2.561,2.633,2.707,2.782,2.858,2.936 };	double wt[99] = { 0., 1.0079,4.00260,6.941,9.01218,10.81,12.011, 			14.0067,15.9994,18.9984,20.179,22.98977,24.305,26.98154,28.0855, 			30.97376,32.06,35.453,39.948,39.0983,40.08,44.9559,47.88,50.9415, 			51.996,54.9380,55.847,58.9332,58.69,63.546,65.38,69.72,72.59, 			74.9216,78.96,79.904,83.80,85.4678,87.62,88.9059,91.22,92.9064, 			95.94,98.,101.07,102.9055,106.42,107.868,112.41,114.82,118.69, 			121.75,127.60,126.9045,131.29,			132.9054,137.33,138.9055,140.12,140.9077, 144.24, 			145.,150.36,151.96,157.25,158.9254,162.50,164.9304,167.26, 168.9342,			173.04,174.67,178.49,180.9479,183.85,186.207,190.2,192.22,195.08, 			196.9655,200.59,204.383,207.2,208.9804,209.,210.,222.,223., 			226.0254,227.0278,232.0381,231.0359,238.0482,237.0482,239.,243., 			247.,247.,251. };	int norb[99] = { 0,0,0,2,2,3,3,4,4,4,4,4,4,5,6,7,7,7,7,7,7,7, 			7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,12,12,13,13,14,14,14,14,14, 			14,14,14,14,14,14,14,14,17,17,17,18,18,18,18,18,18,19,19,19,			19,19,19,19,19,20,20,20,21,21,21,21,21,22,22,23,23,24,24,24,			24,24,24,24,24,24,24,24,24,24,24,24 };	char elements[104][3] ={ "  ",			"H ","HE","LI","BE","B ","C ","N ","O ","F ","NE",			"NA","MG","AL","SI","P ","S ","CL","AR","K ","CA",			"SC","TI","V ","CR","MN","FE","CO","NI","CU","ZN",			"GA","GE","AS","SE","BR","KR","RB","SR","Y ","ZR",			"NB","MO","TC","RU","RH","PD","AG","CD","IN","SN",			"SB","TE","I ","XE","CS","BA","LA","CE","PR","ND",			"PM","SM","EU","GD","TB","DY","HO","ER","TM","YB",			"LU","HF","TA","W ","RE","OS","IR","PT","AU","HG",			"TL","PB","BI","PO","AT","RN","FR","RA","AC","TH",			"PA","U ","NP","PU","AM","CM","BK","CF","ES","FM",			"MD","NO","LW" };	fpos_t record[104] = { 0, 0, 0, 0, 560, 1120, 1960,		2800, 3920, 5040, 6160, 7280, 8422, 9564,		10986, 12688, 14670, 16652, 18634, 20616, 22598,		24580, 26562, 28544, 30806, 33348, 35890, 38432,		40974, 43538, 46102, 48710, 51318, 53926, 56534,		59142, 61750, 64358, 66966, 70414, 73862, 77590,		81318, 85326, 89334, 93342, 97350, 101358, 105366,		109374, 113382, 117390, 121398, 125428, 129458, 133488,		138380, 143294, 148208, 153402, 158596, 163790, 169028,		174266, 179504, 185022, 190540, 196058, 201576, 207094,		212612, 218130, 223648, 229446, 235244, 241042, 247120,		253198, 259276, 265354, 271410, 277746, 284082, 290698,		297314, 304210, 311128, 318046, 324964, 331904, 338844,		345784, 352746, 359708, 366670, 373632, 380594, 387556,		394518, 0, 0, 0, 0, 0};	c_byte = 2;	i_byte = sizeof nj;	sd_byte = sizeof sd;/*	printf("\n=========================================\n"); *//*	for(i=0;i<=103;i++) { elements[i][2]='\0'; } */	for(i=0;i<=24;i++) { fpp[i]=0. ; fp[i]=0.; }	nat[0] = '\0';	if (!cache_init) {				/* initialize the cache the first time *//*		printf(" initializing the cache\n"); */		for (i=0;i<CACHE_LEN;i++) {			cache[i].z = 0;			cache[i].hits = -1;		/* (hits < 0) --> flags empty slot */			cache[i].xk = 0.;			cache[i].mu = 0.;			cache[i].df.r = 0.;			cache[i].df.i = 0.;		}		cache_init = 1;	}	if (toupper(atom_in[0])=='Z' && atom_in[1]<'A') {		sscanf(atom_in+1,"%lf",&zz);		fprime.r = zz; fprime.i = 0.;		return(fprime);	}	iz = 0;	natom[0] = '\0';	if (atom_in[0]==' ') {		printf("get_fp, ERROR -- no leading spaces allowed in atom name\n");		exit(-3);		fprime.r = -3;		return (fprime);	}	if (nord<0 || nord>3) {		printf(" ERROR -- nord must be in [0,3]\n");		exit(-5);		fprime.r = -5;		return (fprime);	}	natom[0] = toupper(atom_in[0]);				/* force to upper case for comariing*/	natom[1] = toupper(atom_in[1]);/*	printf("natom = '%s'\n",natom); */	if (natom[1]<'A' || natom[1]>'Z') natom[1] = ' ';	natom[2] = '\0'; 	for (i=1;i<=103;i++) { if (!strcmp(elements[i],natom)) iz = i; }	/* atomic number */	if (iz<=0) {		printf("get_fp, ERROR -- atomic number not found\n");		exit(-3);		fprime.r = -3;		return (fprime);	}	if ( (record[iz]<=0) && (iz>3) ) {		printf("get_fp, ERROR -- That element not allowed\n");		exit(-3);		fprime.r = -3;		return (fprime);	}	fo = get_fo(H,atom_in);						/* get ordinary atomic form factor */	if (iz<=2) {								/* no correction for H or He */		fprime.r = fo; fprime.i = 0.;		return(fprime);	}	for (i=0;i<CACHE_LEN;i++) {					/* check the cache */		if (cache[i].z==iz  &&  fabs((cache[i].xk)-xk)<DELTA_XK) break; 	}	if (i<CACHE_LEN && cache[i].hits>=0) {		/* found a match in the cache *//*		printf(" hit the cache at position %d, for Z = %d,  hits=%d\n",i,cache[i].z,cache[i].hits); */		fprime.r = cache[i].df.r + fo;		fprime.i = cache[i].df.i;		*pmu = cache[i].mu;		cache[i].hits += 1;						/* increment number of hits */		return(fprime);	}	no = norb[iz];								/* number of orbitals */	lun = fopen(DATA,"rb");	if (!lun) {		printf("cannot open 'XSECTDAT2.BIN'\n");		exit(-6);		fprime.r = -6;		return (fprime);	}	if (fsetpos(lun,&record[iz])!=0) {		printf("get_fp, ERROR -- cannot position in file\n");		exit(-7);		fprime.r = -7;		return (fprime);	}	for(j=1;j<=no;j++) {						/* once for each orbital *//* *		nat = atomic symbol *		nj = orbital sequence number *		ew = energy in KeV *		SIG = cross-section in barns *		BE = binding energy(KeV) *		IF = 0,1,2 function type */		for(k=1;k<=MX;k++) {		/* get MX energies and X-sections for orbital j */			fread(nat,1,c_byte,lun); nat[c_byte]='\0';			fread(&nj,1,i_byte,lun);			fread(&sd,1,sd_byte,lun);			ew[k] = sd;			fread(&sd,1,sd_byte,lun);			sig[k] = sd;			if (strcmp(nat,natom) || nj!=j) {				printf("nat != natom .or. nj!=j\n");				exit(-8);				fprime.r = -8;				return (fprime);			}		}/* *		Read 5 energies and X-sections for orbital j for the Gauss *		integration points, binding energy and and function type also */		for (k=1;k<=5;k++) {			fread(nat,1,c_byte,lun); nat[c_byte]='\0';			fread(&nj,1,i_byte,lun);			fread(&sd,1,sd_byte,lun);			eg[k] = sd;			fread(&sd,1,sd_byte,lun);			sigg[k] = sd;			fread(&sd,1,sd_byte,lun);			be = sd;			fread(&IF,1,i_byte,lun);			if (strcmp(nat,natom)) {				printf("nat.ne.natom 1st check\n");				exit(-8);				fprime.r = -8;				return (fprime);			}			if (nj!=j) {				printf("nj != j\n");				exit(-8);				fprime.r = -8;				return (fprime);			}			if (be<=0.) {				printf("be <= 0\n");				exit(-8);				fprime.r = -8;				return (fprime);			}			ew[k+MX] = eg[k];			sig[k+MX] = sigg[k];		}		nx = MX + 5;		if (IF==0) {				/* read X-section at energy=1.001*binding energy */			nx++;			fread(nat,1,c_byte,lun); nat[c_byte]='\0';			fread(&nj,1,i_byte,lun);			fread(&sd,1,sd_byte,lun);			ew[nx] = sd;			fread(&sd,1,sd_byte,lun);			sig[nx] = sd;			if (strcmp(nat,natom)) {				printf("nat != natom 2nd check\n");				exit(-8);				fprime.r = -8;				return (fprime);			}			sigedg=sig[nx];		}		bb = be / C1;		for (i=1;i<=5;i++) { sigg[i] = sigg[i] / AU; }		sort_fp(nx,ew,sig);				/* sort all X sections */		sort_fp(5,eg,sigg);				/* sort 5 X-sections at integration pnts */		for (k=1;k<=nx;k++) {			/* change to logs for interpolation */			el[k]=log(ew[k]);			sl[k]=0.;			if (sig[k]!=0.0) sl[k]=log(sig[k]);		}		mf = 0;		zx = log(xk);				/* ZX=log of XRAY(KEV) energy */		cx = 0.;		if (be <= xk) {			if (nord==0) {				xsect(zx,el,sl,&cx,nx);			}			else {				for (m=1;m<=nx;m++) {					n1 = m;					if (sl[m]!=0.0) break;				}				mm = nx - n1 + 1;				cx = aknint(zx,mm,nord,&el[n1-1],&sl[n1-1],T);				cx = exp(cx);		/* cx IS THE INTERPOLATED X SECTION IN BARNS */			}			cxb = cxb + cx;			/* cxb is sum to get MU/RHO */			cx = cx / AU;			/* change cx to atomic units */		}		icount = 6;		rx = xk / C1;				/* rx=xray energy in atomic units */		if (IF!=0 || be<xk) {			if (IF==0) { fp[j] = gauss(sigma0)*C/(2.0*PI2); }			if (IF==1) { fp[j] = gauss(sigma1)*C/(2.0*PI2); }			if (IF==2) { fp[j] = gauss(sigma2)*C/(2.0*PI2); }		}		else {			sedge = sigedg / AU;	/* SEDGE is XSECTION in atomic units at ENERGY=1.001*BE */			cx = 0.0;			fp[j] = gauss(sigma3)*C/(2.0*PI2);			mf = 3;		}		fpp[j] = 0.;		if (cx!=0.0) fpp[j] = C*cx*rx/(4.0*PI);		corr = 0.0;		if (cx!=0.0) corr = -cx*rx*0.5*log((rx+bb)/(rx-bb))*C/(2.0*PI2);		if (mf==3) corr = 0.5 * sedge * bb*bb * log((-bb+rx)/(-bb-rx))/rx*C/(2.*PI2);/*		printf("    fp[%d] = %10g,   corr = %10g,  sum = %10g\n",j,fp[j],corr,fp[j]+corr); */		fp[j] = fp[j] + corr;	}	fclose(lun);	sumfp = 0.0;	sumfpp = 0.0;	for(j=1;j<=no;j++) { sumfp += fp[j]; }	xjensn = -0.5*iz*pow((xk/C1/137.0367/137.0367),2.);	et = -eterm[iz];/*	printf("for Æf',  sumfp = %g,  et = %g,  xjensn = %g\n",sumfp,et,xjensn); */	sumfp = sumfp + et + xjensn;	for(j=1;j<=no;j++) { sumfpp += fpp[j]; }	cxb = cxb * 0.602472 / wt[iz];	*pmu = cxb;/*	printf(" Æf' = %g,   Æf'' = %g,   fo = %g\n",sumfp,sumfpp,fo); */	fprime.r = sumfp + fo;	fprime.i = sumfpp;/* start update of cache */	i_hit_min = hits_min = -1;		/* find the next available slot in cache*/	for (i=0;i<CACHE_LEN;i++) {		if (cache[i].hits <= hits_min) { 			i_hit_min = i;			hits_min = cache[i].hits;			if (hits_min < 0) break;		}	}/*	printf(" update the cache for Z = %d, at cache slot %d\n",iz,i_hit_min); */	cache[i_hit_min].z = iz;		/* i_hit_min is the position in the cache to fill */	cache[i_hit_min].hits = 0;	cache[i_hit_min].xk = xk;	cache[i_hit_min].mu = *pmu;	cache[i_hit_min].df.r = sumfp;	cache[i_hit_min].df.i = sumfpp;	return(fprime);}/***********************************************************************/double get_fo(	double		H,				/* 2*pi/d */	char		in_atom[])		/* name of atom desired */{	float	s;					/* sin(theta)/lambda */	float	s2;					/* s^2 */	double	sum;				/* the answer */	int		i;					/* loop index */	int		n;					/* number of atom in coef[n] */	char	atom[5];			/* uppercase version in_atom */	struct atomic_def {		char name[5];		float	a[4], b[4], c;		} coef[] = {		"H",    0.39875, 0.31285, 0.2144,  0.07135, 58.3331, 14.7175, 236.7147, 3.4848, 0.00125,		"H-1",  0.7975,  0.6257,  0.4288,  0.1427,  58.3331, 14.7175, 236.7147, 3.4848, 0.0025,		"HE",   0.76844, 0.72694, 0.27631, 0.21572, 10.9071, 4.30779, 1.33127, 25.6848, 0.01249,		"LI",   0.99279, 0.87402, 0.84240, 0.23131, 4.33979, 1.26006, 98.7088, 212.088, 0.05988,		"LI+1", 6.08475, 0.86773, 0.80588, 0.17720, 0.00498, 1.53730, 4.28524, 9.81413,-5.93560,		"BE",   2.22744, 1.55249, 1.40060, 0.58290, 0.04965, 42.9165, 1.66379, 100.361,-1.76339,		"BE+2", 5.69034, 1.19706, 1.03057, 0.20150,-0.01336, 0.39000, 1.97441, 4.90642,-6.11950,		"B",    2.03876, 1.41491, 1.11609, 0.73273, 23.0888, 0.97848, 59.8985, 0.08538,-0.30409,		"C",    1.93019, 1.87812, 1.57415, 0.37108, 12.7188, 28.6498, 0.59645, 65.0337, 0.24637,		"N",    12.7913, 3.28546, 1.76483, 0.54709, 0.02064, 10.7018, 30.7773, 1.48044,-11.3926,		"O",    2.95648, 2.45240, 1.50510, 0.78135, 13.8964, 5.91765, 0.34537, 34.0811, 0.30413,		"O-1",  3.22563, 3.01717, 1.42553, 0.90525, 18.4991, 6.65680, 0.40589, 61.1889, 0.42362,		"F",    3.30393, 3.01753, 1.35754, 0.83645, 11.2651, 4.66504, 0.33760, 27.9898, 0.48398,		"F-1",  3.63220, 3.51057, 1.26064, 0.94071, 5.27756, 14.7353, 0.44226, 47.3437, 0.65340,		"NA",   5.26400, 2.17549, 1.36690, 1.08859, 4.02579, 10.4796, 0.84222, 133.617, 1.09912,		"NA+1", 3.99479, 3.37245, 1.13877, 0.65118, 3.11047, 7.14318, 0.40692, 15.7319, 0.84267,		"MG",   5.59229, 2.68206, 1.72235, 0.73055, 4.41142, 1.36549, 93.4885, 32.5281, 1.26883,		"MG+2", 4.30491, 3.14719, 1.12859, 0.49034, 2.55961, 5.60660, 0.41574, 11.4840, 0.92893,		"AL",   5.35047, 2.92451, 2.27309, 1.16531, 3.48665, 1.20535, 42.6051, 107.170, 1.28489,		"AL+3", 4.17448, 3.38760, 1.20296, 0.52814, 1.93816, 4.14553, 0.22875, 8.28524, 0.70679,		"SI",   5.79411, 3.22390, 2.42795, 1.32149, 2.57104, 34.1775, 0.86937, 85.3410, 1.23139,		"SI+4", 4.43918, 3.20345, 1.19453, 0.41653, 1.64167, 3.43757, 0.21490, 6.65365, 0.74630,		"P",    6.92073, 4.14396, 2.01697, 1.53860, 1.83778, 27.0198, 0.21318, 67.1086, 0.37870,		"S",    7.18742, 5.88671, 5.15858, 1.64403, 1.43280, 0.02865, 22.1101, 55.4651,-3.87732,		"CL",   9.83957, 7.53181, 6.07100, 1.87128,-0.00053, 1.11119, 18.0846, 45.3666,-8.31430,		"CL-1", 18.0842, 7.47202, 6.46337, 2.43918, 0.00129, 1.12976, 19.3079, 59.0633,-16.4654,		"AR",   16.8752, 8.32256, 6.91326, 2.18515,-0.01456, 0.83310, 14.9177, 37.2256,-16.2972,		"K",    8.11756, 7.48062, 1.07795, 0.97218, 12.6684, 0.76409, 211.222, 37.2727, 1.35009,		"K+1",  9.70659, 7.37245, 5.67228, 1.90668, 0.59947, 11.8765,-0.08359, 26.7668,-6.65819,		"CA",   8.60272, 7.50769, 1.75117, 0.96216, 10.2636, 0.62794, 149.301, 60.2274, 1.17430,		"CA+2", 13.2063, 11.0586, 7.73221, 1.72057, 0.39466,-0.08204, 9.62976, 20.3341,-15.7176,		"SC",   9.06482, 7.55526, 2.05017, 1.28745, 8.77431, 0.53306, 123.880, 36.8890, 1.03849,		"SC+3", 13.4008, 8.02730, 1.65943, 1.57936, 0.29854, 7.96290,-0.28604, 16.0662,-6.66668,		"TI",   9.54969, 7.60067, 2.17223, 1.75438, 7.60579, 0.45899, 109.099, 27.5715, 0.91762,		"TI+3", 17.7344, 8.73816, 5.25691, 1.92134, 0.22061, 7.04716,-0.15762, 15.9768,-14.6519,		"TI+4", 19.5114, 8.23473, 2.01341, 1.52080, 0.17885, 6.67018,-0.29263, 12.9464,-13.2803,		"V",    10.0661, 7.61420, 2.23551, 2.23170, 6.67721, 0.40322, 98.5954, 22.5720, 0.84574,		"V+2",  9.34513, 7.68833, 2.94531, 0.26998, 6.49985, 0.39491, 15.9868, 41.0832, 0.75143,		"V+3",  9.43141, 7.74190, 2.15343, 0.01686, 6.39535, 0.38335, 15.1908, 63.9690, 0.65657,		"V+5",  15.6887, 8.14208, 2.03081,-9.57602, 0.67900, 5.40135, 9.97278, 0.94046, 1.71430,		"CR",   10.4757, 7.51402, 3.50115, 1.54902, 6.01658, 0.37426, 19.0654, 97.4599, 0.95226,		"CR+2", 9.54034, 7.75090, 3.58274, 0.50911, 5.66078, 0.34426, 13.3075, 32.4224, 0.61690,		"CR+3", 9.68090, 7.81136, 2.87603, 0.11357, 5.59463, 0.33439, 12.8288, 32.8761, 0.51827,		"MN",   11.2519, 7.36935, 3.04107, 2.27703, 5.34818, 0.34373, 17.4089, 84.2139, 1.05195,		"MN+2", 9.78094, 7.79153, 4.18544, 0.72736, 4.98303, 0.30421, 11.4399, 27.7750, 0.51454,		"MN+3", 9.84521, 7.87194, 3.56531, 0.32361, 4.91797, 0.29439, 10.8171, 24.1281, 0.39397,		"MN+4", 9.96253, 7.97057, 2.76067, 0.05445, 4.84850, 0.28330, 10.4852, 27.5730, 0.25188,		"FE",   11.9185, 7.04848, 3.34326, 2.27228, 4.87394, 0.34023, 15.9330, 79.0339, 1.40818,		"FE+2", 10.1270, 7.78007, 4.71825, 0.89547, 4.44133, 0.27418, 10.1451, 24.8302, 0.47888,		"FE+3", 10.0333, 7.90625, 4.20562, 0.55048, 4.36007, 0.26250, 9.35847, 20.4105, 0.30429,		"CO",   12.6158, 6.62642, 3.57722, 2.25644, 4.48994, 0.35459, 14.8402, 74.7352, 1.91452,		"CO+2", 10.5942, 7.67791, 5.15947, 1.01440, 4.00858, 0.25410, 9.21931, 22.7516, 0.55358,		"CO+3", 10.3380, 7.88173, 4.76795, 0.72559, 3.90969, 0.23867, 8.35583, 18.3491, 0.28667,		"NI",   13.3239, 6.18746, 3.74792, 2.23195, 4.17742, 0.38682, 14.0123, 71.1195, 2.49899,		"NI+2", 11.1650, 7.45636, 5.51106, 1.09496, 3.65944, 0.24397, 8.52556, 21.1647, 0.77218,		"NI+3", 10.7806, 7.75868, 5.22746, 0.84711, 3.54770, 0.22314, 7.64468, 16.9673, 0.38604,		"CU",   13.9352, 5.84833, 4.64221, 1.44753, 3.97779, 0.44555, 13.3971, 74.1605, 3.11686,		"CU+1", 12.4655, 6.63111, 5.76679, 1.34230, 3.54270, 0.28920, 9.31140, 26.9799, 1.79285,		"CU+2", 11.8168, 7.11181, 5.78135, 1.14523, 3.37484, 0.24408, 7.98760, 19.8970, 1.14431,		"ZN",   14.6744, 5.62816, 3.92540, 2.16398, 3.71486, 0.50033, 12.8862, 65.4071, 3.59838,		"ZN+2", 12.5225, 6.68507, 5.98382, 1.17317, 3.13961, 0.25431, 7.55544, 18.8543, 1.63497,		"GA",   15.3412, 5.74150, 3.10733, 2.52764, 3.63868, 0.65640, 16.0719, 70.7609, 4.26842,		"GA+3", 12.6920, 6.69883, 6.06692, 1.00660, 2.80262, 0.22789, 6.36441, 14.4122, 1.53545,		"GE",   15.4378, 6.00432, 3.05158, 2.93572, 3.39715, 0.73097, 18.9533, 63.7969, 4.56068,		"AS",   15.4043, 6.13723, 3.74679, 3.01390, 3.07517, 0.74113, 21.0014, 57.7446, 4.69149,		"SE",   15.5372, 5.98288, 4.83996, 2.93549, 2.71530, 0.68962, 21.0079, 52.4308, 4.70026,		"BR",   15.9934, 6.02439, 5.51599, 2.88716, 2.35651, 19.7393, 0.58143, 47.3323, 4.57602,		"BR-1", 15.4080, 6.78083, 6.00715, 2.99332, 2.43532, 22.0832, 0.68621, 64.9193, 4.80234,		"KR",   16.8494, 7.19790, 4.92564, 2.91606, 2.01856, 18.0409, 0.39741, 42.5054, 4.10864,		"RB",   11.4809, 9.46904, 9.16981, 1.42608, 1.08140, 18.2800, 2.38825, 185.293, 5.43921,		"RB+1", 17.8943, 8.59341, 7.91428, 2.47499, 1.71750, 0.09258, 15.4484, 32.5110,-.087756,		"SR",   11.6164, 9.73009, 8.68081, 2.60986, 1.85574, 14.6109, 0.89852, 139.830, 5.34841,		"SR+2", 18.2430, 8.90811, 1.69192,-32.1118, 1.51215, 13.6536, 27.8238,-0.01488, 39.2691,		"Y",    19.0567, 6.50783, 4.81524, 2.84786, 1.24615, 9.68019, 18.8903, 121.353, 5.76121,		"Y+3",  18.4207, 9.75213, 1.05270,-33.4755, 1.34457, 12.0631, 25.1684,-0.01023, 40.2513,		"ZR",   19.2273, 10.1378, 2.48177, 2.42892, 1.15488, 10.7877, 120.126, 33.3722, 5.71886,		"ZR+4", 19.1301, 10.1098, 0.98896,-0.00004, 1.16051, 10.4084, 20.7214,-3.20442, 5.77164,		"NB",   19.3496, 10.8737, 3.47687, 1.64516, 1.06626, 10.5977, 32.6174, 120.397, 5.65073,		"NB+3", 19.1248, 18.2989, 11.0121, 2.04325, 1.07235, 0.00315, 10.3385, 25.9292,-12.4799,		"NB+5", 19.0175, 10.7591, 1.09900, 0.48469, 1.06028, 9.36239, 0.03765, 20.9764, 4.64045,		"MO",   19.3885, 11.8308, 3.75919, 1.46772, 0.97877, 10.0885, 31.9738, 117.932, 5.55047,		"MO+3", 19.6761, 18.0893, 11.7086, 2.50624, 0.95118,-0.00669, 9.61097, 24.0356,-12.9813,		"MO+5", 19.6054, 17.9292, 11.3451, 1.04247, 0.94029,-0.00795, 8.76715, 19.3690,-12.9217,		"MO+6", 19.4800, 17.6328, 11.0940, 0.37154, 0.94043,-0.00723, 8.29745, 18.9700,-12.5778,		"TC",   19.3597, 12.8087, 3.41372, 1.99926, 0.89356, 9.27497, 32.3513, 107.406, 5.41556,		"RU",   19.4316, 13.7309, 4.26537, 1.28720, 0.82092, 8.97737, 28.2621, 111.501, 5.28192,		"RU+3", 20.8024, 13.2995, 3.27542, 2.21026, 0.74711, 8.36626, 20.6179,-0.14664, 1.41087,		"RU+4", 41.5821, 12.9936, 2.71276,-24.2593, 0.61466, 7.99801, 18.1564, 0.43857, 6.97025,		"RH",   19.4524, 14.6845, 4.50240, 1.24740, 0.75019, 8.42622, 26.1564, 107.780, 5.11007,		"RH+3", 25.0958, 14.1510, 3.64428,-12.5768, 0.61346, 7.80244, 19.0932, 0.13532, 11.6838,		"RH+4", 41.5236, 13.8272, 3.07969,-25.9694, 0.52905, 7.49419, 16.9498, 0.32686, 8.53824,		"PD",   19.5123, 15.3800, 5.38330, 0.81015, 0.68583, 7.95714, 23.1808, 65.9295, 4.91427,		"PD+2", 19.4652, 15.5805, 4.04748, 0.02216, 0.68159, 7.80880, 20.9573, 110.020, 4.88510,		"PD+4", 51.1288, 14.6979, 3.41607,-38.2678, 0.43734, 7.03139, 15.8623, 0.26589, 11.0241,		"AG",   19.5284, 16.5811, 4.99150, 1.21404, 0.62387, 7.39504, 22.2282, 100.226, 4.68114,		"AG+1", 19.5416, 16.4239, 5.12995, 0.24053, 0.62273, 7.39663, 20.5530, 59.0604, 4.66470,		"AG+2", 19.5152, 16.4852, 4.32525, 0.02777, 0.62050, 73.0347, 19.3673, 92.9184, 4.64695,		"CD",   19.5528, 17.5717, 4.47374, 1.98562, 0.56604, 6.79630, 21.2907, 85.2777, 4.41158,		"CD+2", 19.5901, 17.3740, 4.62594, 0.03770, 0.56389, 6.83082, 17.8856, 76.2909, 4.37269,		"IN",   19.5872, 18.7169, 4.02722, 2.51452, 0.51510, 6.29430, 22.7308, 88.5675, 4.14542,		"IN+3", 19.6698, 18.1942, 4.09851, 0.00365, 0.50926, 6.28098, 15.4189, 160.227, 4.03396,		"SN",   19.6527, 19.5108, 3.86895, 3.14764, 0.46604, 5.76321, 24.0627, 78.1533, 3.81227,		"SN+2", 19.7166, 18.9265, 3.79775, 1.86248, 0.46027, 5.66448, 17.7248, 42.8086, 3.69648,		"SN+4", 19.7914, 18.9162, 3.64761, 0.00000, 0.45879, 5.76682, 13.3733, 0.00000, 3.64494,		"SB",   20.0755, 19.7766, 4.30389, 3.44952, 5.24328, 0.41858, 26.0178, 70.1646, 3.38881,		"SB+3", 19.8617, 19.5199, 3.73465, 1.61027, 0.41409, 5.18292, 16.8529, 35.1406, 3.27356,		"SB+5", 19.9613, 19.5889, 3.24333, 0.00000, 0.41262, 5.30028, 11.7603, 0.00000, 3.20701,		"TE",   20.4608, 20.0336, 5.38664, 3.33079, 4.74225, 0.37041, 27.3458, 65.0573, 2.78462,		"I",    20.7492, 20.5640, 6.86158, 2.97589, 4.27091, 0.31960, 27.3186, 61.5375, 1.84739,		"I-1",  20.8307, 20.4454, 7.52618, 3.18616, 4.29514, 0.32402, 29.8990, 81.4344, 2.00513,		"XE",   21.6679, 21.0085, 8.43382, 2.62265, 0.26422, 3.83526, 26.2297, 58.4830, 0.26635,		"CS",   22.3163, 21.1792, 10.7382, 1.46163, 0.23092, 3.49464, 25.1864, 232.829,-0.70709,		"CS+1", 23.9649, 21.2204, 9.76727, 1.61550, 0.20448, 3.43876, 23.4941, 49.7057,-2.56728,		"BA",   27.7489, 21.3777, 11.0400, 2.68186, 0.15152, 3.09817, 20.6774, 178.819,-6.85854,		"BA+2", 29.2996, 21.4669, 10.9209, 0.80126, 0.14047, 3.08785, 20.8818, 46.8842,-8.48753,		"LA",   33.2109, 21.7181, 11.6222, 3.17239, 0.11040, 2.83641, 19.3886, 144.438,-12.7404,		"LA+3", 43.6346, 21.7192, 11.7264, 0.32945, 0.07854, 2.78360, 18.4930, 49.2222,-23.4085,		"CE",   29.4100, 22.2428, 11.9818, 3.19259, 0.12335, 2.74837, 18.3794, 139.603,-8.84560,		"CE+3", 49.1105, 22.3499, 11.8399, 0.67455, 0.06535, 2.67229, 17.2040, 38.1904,-28.9739,		"CE+4", 66.7693, 21.8563, 12.2486, 0.09617, 0.04464, 2.53711, 16.4477, 64.4675,-46.9691,		"PR",   22.9220, 22.2518, 12.2269, 2.72431, 2.78604, 0.18015, 17.6663, 160.915,-1.13930,		"PR+3", 49.4655, 22.9705, 11.8015, 1.12179, 0.06197, 2.57634, 16.0371, 32.3673,-29.3586,		"PR+4", 62.6752, 22.4952, 12.4946, 0.20294, 0.04586, 2.45900, 15.5713, 46.5889,-42.8667,		"ND",   23.4069, 19.7073, 12.5016, 2.72850, 2.71587, 0.20950, 16.9122, 156.556, 1.64038,		"ND+3", 49.4292, 23.6116, 11.6190, 1.68986, 0.05936, 2.48611, 14.9366, 28.4515,-29.3493,		"PM",   23.8480, 17.5535, 12.7324, 2.72975, 2.65746, 0.24780, 16.2463, 152.682, 4.12018,		"PM+3", 49.2699, 24.2700, 11.3481, 2.32869, 0.05709, 2.40059, 13.9124, 25.6906,-29.2165,		"SM",   24.2242, 15.9132, 12.9238, 2.72836, 2.60993, 0.29475, 15.6554, 149.221, 6.19355,		"SM+3", 36.3271, 24.8202, 11.3426, 2.62300, 0.07823, 2.33602, 13.1872, 24.3996,-16.1429,		"EU",   24.5148, 14.8058, 13.0799, 2.72477, 2.57225, 0.34930, 15.1280, 146.103, 7.85731,		"EU+2", 25.6516, 23.9387, 10.5738, 4.05853, 2.36073, 0.13260, 12.6495, 25.0026,-3.22358,		"EU+3", 33.2862, 25.5041, 11.1494, 3.13496, 0.08350, 2.26275, 12.3883, 22.8351,-13.0748,		"GD",   24.4004, 14.0308, 13.1754, 3.24472, 2.47491, 0.40238, 14.4670, 119.738, 9.12488,		"GD+3", 29.0290, 26.1387, 11.0510, 3.52244, 0.09521, 2.19696, 11.7141, 21.6929,-8.74150,		"TB",   24.3736, 13.8649, 13.2510, 3.24435, 2.46637, 0.47517, 14.0424, 117.446, 10.2420,		"TB+3", 26.7821, 25.9463, 10.9724, 3.88172, 2.13333, 0.10597, 11.0974, 20.7042,-5.58307,		"DY",   24.6193, 14.2735, 13.3567, 2.70316, 2.52208, 0.54556, 13.8487, 138.385, 11.0290,		"DY+3", 27.3805, 22.2062, 10.9975, 4.10030, 2.07832, 0.12643, 10.5960, 19.9671,-1.68516,		"HO",   24.3162, 14.9012, 13.3895, 2.69309, 2.52724, 0.61572, 13.5041, 136.246, 11.6817,		"HO+3", 27.9956, 19.9560, 11.0106, 4.33205, 2.02324, 0.14275, 10.1165, 19.2589, 0.70499,		"ER",   23.8201, 15.8796, 13.3938, 2.68190, 2.54419, 0.68445, 13.1932, 134.282, 12.2062,		"ER+3", 28.5315, 17.4316, 11.1113, 4.43156, 1.97796, 0.17182, 9.73821, 18.7294, 3.49325,		"TM",   23.1386, 17.1707, 13.3703, 2.66981, 2.57320, 0.74948, 12.9126, 132.468, 12.6322,		"TM+3", 29.0215, 15.6168, 11.2288, 4.49403, 1.93707, 0.20467, 9.40342, 18.2607, 5.63812,		"YB",   22.3028, 18.7202, 13.3200, 2.65701, 2.61393, 0.80868, 12.6590, 130.783, 12.9818,		"YB+2", 29.1313, 13.5855, 11.4132, 4.69659, 1.99979, 0.32335, 9.59277, 20.3507, 9.17182,		"YB+3", 29.4761, 14.4357, 11.3446, 4.54681, 1.89879, 0.23793, 9.09408, 17.8206, 7.19600,		"LU",   21.1866, 20.1760, 13.0532, 3.21190, 0.88654, 2.68610, 12.2746, 107.128, 13.3489,		"LU+3", 29.8480, 13.6268, 11.4750, 4.56009, 1.86596, 0.27623, 8.82479, 17.4364, 8.48923,		"HF",   24.6725, 17.2295, 12.8069, 3.55970, 0.97400, 2.89038, 12.2897, 93.4381, 13.7049,		"TA",   28.1757, 14.4288, 12.6412, 3.74436, 1.04034, 3.20784, 12.5054, 85.0183, 13.9824,		"W",    31.0935, 12.5273, 12.3769, 3.79138, 1.07885, 12.8331, 3.63298, 79.7647, 14.1842,		"RE",   33.2961, 12.3497, 11.2819, 3.72367, 1.09315, 13.2559, 4.16736, 76.6562, 14.3239,		"OS",   34.8667, 11.9524, 11.1851, 3.56436, 1.08840, 13.8042, 4.79179, 75.1399, 14.4097,		"IR",   35.9454, 11.9980, 11.2501, 3.34312, 1.06924, 5.43443, 14.4983, 74.7918, 14.4449,		"PT",   36.8102, 13.0747, 11.3323, 2.31421, 1.04422, 6.07340, 15.7018, 73.8375, 14.4526,		"AU",   37.3027, 14.9306, 10.3425, 2.01229, 1.00810, 6.52550, 16.5100, 76.9117, 14.3992,		"HG",   37.5186, 17.0353, 8.51121, 2.63340, 0.96455, 6.65786, 16.8438, 76.7228, 14.2911,		"TL",   37.6947, 19.7195, 6.38290, 3.00960, 0.92263, 6.78248, 19.2435, 85.9267, 14.1800,		"PB",   37.7383, 21.3394, 5.17527, 3.71604, 0.87755, 6.58964, 21.2437, 78.8094, 14.0203,		"BI",   37.7143, 22.4542, 4.84549, 4.14816, 0.83222, 6.27051, 24.4693, 72.1558, 13.8301,		"PO",   37.6297, 23.1323, 5.59203, 4.04218, 0.78640, 5.86644, 27.8678, 68.1617, 13.5991,		"AT",   37.4971, 23.5635, 7.15953, 3.45924, 0.74012, 5.42694, 29.8350, 66.3564, 13.3183,		"RN",   37.3308, 23.8933, 9.02222, 2.77349, 0.69354, 4.98696, 30.0338, 65.5799, 12.9796,		"FR",   37.1902, 24.1306, 11.5026, 1.47980, 0.65303, 4.61305, 29.2597, 257.965, 12.6868,		"RA",   36.9820, 24.2495, 11.8719, 2.72428, 0.60394, 4.17857, 24.3782, 200.024, 12.1642,		"AC",   36.8705, 24.7131, 12.3889, 3.26501, 0.56458, 3.88776, 23.1506, 161.726, 11.7484,		"TH",   36.7754, 25.2506, 13.0681, 3.63791, 0.52510, 3.61658, 22.3410, 139.164, 11.2497,		"PA",   37.1457, 25.2998, 13.7846, 3.29611, 0.52020, 3.66300, 20.6539, 150.973, 11.4561,		"U",    37.2808, 25.6563, 14.3501, 3.30732, 0.50239, 3.58562, 19.6342, 146.633, 11.3864,		"NP",   37.3968, 26.0671, 14.8366, 3.31586, 0.48676, 3.52325, 18.7419, 142.798, 11.3632,		"PU",   37.6407, 26.5603, 15.4492, 2.79814, 0.47976, 3.57178, 17.9814, 165.232, 11.5358,		"AM",   37.6909, 27.1436, 15.7842, 2.79600, 0.46617, 3.52195, 17.3069, 161.931, 11.5685,		"CM",   37.5543, 27.6657, 15.8858, 3.32758, 0.44932, 3.38713, 16.6498, 133.547, 11.5431,		"BK",   37.5273, 28.3202, 16.1181, 3.32793, 0.43930, 3.35014, 16.1000, 131.027, 11.6823,		"CF",   37.6111, 29.2465, 16.4566, 2.78216, 0.43255, 3.39285, 15.6791, 153.766, 11.8853,		"ES",   37.4979, 30.0495, 16.5881, 2.77596, 0.42353, 3.35234, 15.2381, 151.474, 12.0698,		"FM",   37.3380, 30.8936, 16.6818, 2.76929, 0.41562, 3.31193, 14.8362, 149.344, 12.2983,		"MD",   37.1301, 31.7721, 16.7422, 2.76232, 0.40883, 3.27132, 14.4683, 147.353, 12.5741,		"NO",   36.8731, 32.6784, 16.7732, 2.75513, 0.40324, 3.23045, 14.1302, 145.481, 12.9008,		"LW",   36.3813, 33.1999, 16.6469, 3.31406, 0.40165, 3.13608, 13.7255, 119.377, 13.4313,		"",     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0				};	s = fabs(H) / (4*PI);	for (i=0;i<=3;i++) { atom[i] = toupper(in_atom[i]); }	atom[4] = '\0';	if (atom[0]<' ') { printf("name of atom is a blank string\n"); return -2 ; }	for (n=0;(strcmp(coef[n].name,atom)!=0 && (coef[n].name[0]>' ')); n++) ;	if (coef[n].name[0]<' ') { printf("get_fo.c, ERROR -- input string not found\n"); return -3; }	s2 = s*s;	sum = coef[n].c;	for(i=0;i<=3;i++) { sum += (coef[n].a[i])*exp(-(coef[n].b[i])*s2); }	return(sum);}/***********************************************************************/void xsect(double zx,double el[15],double sl[15],double *cx,int nx){	double	er;	double	p;	double	det;	double	a0,a1,a2;	int		l,ll;/*	find el(k) closest to zx */	er=1000000.;	for(l=1;l<=nx;l++) {		p = fabs(zx-el[l]);		if (p<=er) {			er = p;			ll = l;		}	}	ll--;	if (ll==0) ll=1;	if (ll==12) ll=11;	if (sl[ll]==0.) ll++;	det = el[ll+2]*el[ll+2]*(el[ll+1]-el[ll])+el[ll+1]*el[ll+1]*(el[ll]-el[ll+2])+			el[ll]*el[ll]*(el[ll+2]-el[ll+1]);	a0 = (el[ll]*el[ll]*(sl[ll+1]*el[ll+2]-sl[ll+2]*el[ll+1])+el[ll+1]*el[ll+1]*			(sl[ll+2]*el[ll]-sl[ll]*el[ll+2])+el[ll+2]*el[ll+2]*(sl[ll]*el[ll+1]-			sl[ll+1]*el[ll]))/det;	a1 = (el[ll]*el[ll]*(sl[ll+2]-sl[ll+1])+el[ll+1]*el[ll+1]*(sl[ll]-sl[ll+2])+			el[ll+2]*el[ll+2]*(sl[ll+1]-sl[ll]))/det;	a2 = (sl[ll]*(el[ll+2]-el[ll+1])+sl[ll+1]*(el[ll]-el[ll+2])+sl[ll+2]*(el[ll+1]-			el[ll]))/det;	*cx = exp(a0+a1*zx+a2*zx*zx);}/***********************************************************************/double sigma0(double x){	double	x2;	double	rx2;	double	sum;	icount--;	x2 = x*x;	rx2 = rx*rx;	sum = sigg[icount]*pow(bb,3.)/x2/(rx2*x2-bb*bb) - bb*cx*rx2/(rx2*x2-bb*bb);	return(sum);}/***********************************************************************/double sigma1(double x){	icount--;	return( 0.5*pow(bb,3.)*sigg[icount]/(sqrt(x)*(rx*rx*x*x-bb*bb*x)) );}/***********************************************************************/double sigma2(double x){	double	denom;	double	bb2, x2, rx2;	icount--;	x2 = x * x;	bb2 = bb * bb;	rx2 = rx * rx;	denom = x2*x * rx2  -  bb2/x;	return(  2.*bb*sigg[icount]*bb2/(x2*x2)/denom  -  2.*bb*cx*rx2/denom  );}/***********************************************************************/double sigma3(double x){	double	x2,bb2;	x2 = x * x;	bb2 = bb * bb;	icount--;	return(  bb2*bb*(sigg[icount]-sedge*x2) / (x2*(x2*rx*rx-bb2))  );}/***********************************************************************/void lgndr(int m, int k, double *aa, double *z){	double	x[63] = { 0., .06943184420297, .33000947820757, .04691007703067,		 .23076534494716, .03376524289992, .16939530676687, .38069040695840,		 .02544604382862, .12923440720030, .29707742431130, .01985507175123, 		 .10166676129319, .23723379504184, .40828267875217, .01591988024619,		 .08198444633668, .19331428364971, .33787328829809, .01304673574141, 		 .06746831665551, .16029521585049, .28330230293537, .42556283050918, 		 .01088567092697, .05646870011595, .13492399721298, .24045193539659, 		 .36522842202382, .00921968287664, .04794137181476, .11504866290285, 		 .20634102285669, .31608425050091, .43738329574426, .00790847264071,		 .04120080038851, .09921095463335, .17882533027983, .27575362448178, 		 .38477084202243, .00685809565159, .03578255816821, .08639934246512, 		 .15635354759416, .24237568182092, .34044381553605, .44597252564632, 		 .00600374098758, .031363303799647, .075896708294787, .13779113431991, 		 .21451391369574, .30292432646121, .39940295300128, .00529953250417, 		 .02771248846338, .06718439880608, .12229779582250, .19106187779868, 		 .27099161117138, .35919822461038, .45249374508118 };	double	a[69] = { 0., .17392742256873, .32607257743127, .11846344252810, 		 .23931433524968, .28444444444444, .085662246189585, .18038078652407, 		 .23395696728635, .06474248308443, .13985269574464, .19091502525256, 		 .20897959183674, .05061426814519, .11119051722669, .15685332293894, 		 .18134189168918, .04063719418079, .09032408034743, .13030534820147, 	 	 .15617353852000, .16511967750063, .07472567457529, .10954318125799, 		 .13463335965500, .14776211235738, .02783428355809, .06279018473245, 		 .09314510546387, .11659688229599, .13140227225512, .13646254338895, 		 .02358766819326, .05346966299766, .08003916427167, .10158371336153, 		 .11674626826918, .12457352290670, .02024200238266, .04606074991886, 		 .06943675510989, .08907299038097, .10390802376845, .11314159013145, 		 .11627577661544, .01755973016588, .04007904357988, .06075928534395, 		 .07860158357910, .09276919873897, .10259923186065, .10763192673158, 		 .01537662099806, .03518302374405, .05357961023359, .06978533896308, 		 .08313460290850, .09308050000778, .09921574266356, .10128912096278, 		 .01357622970588, .03112676196932, .04757925584125, .06231448562777, 		 .07479799440829, .08457825969750, .09130170752246, .09472530522754 };	int		kk,is,ih,ip,i4,ia;	double	t;	kk = k;	if ((m>16) || (m<4)) kk = 4;	is = 0;	ih = (m+1) / 2 ;	*z = .5;	if ( (m-2*(m/2))==1 ) is = -1;	ip = kk;	t = 0;	if (ip > ih) {		ip = m + 1 - ip;		t = -1;	}	i4 = m - 4;	ia = (i4*(m+4)+is)/4 + ip;	*aa = a[ia];	if ( (ip==ih) && (is < 0) ) return;	ia = ia - (i4+is)/2;	*z = -t + ( (t<0.) ? -x[ia] : x[ia]);	/*  *z = -t + sign(x[ia],t); */}/***********************************************************************/double gauss(double (*y)(double)){	void	lgndr();	double	g,z,a;	int		j;	g = 0.;	for (j=1;j<=5;j++) {		lgndr(5,j,&a,&z);		g += a*((*y)(z));	}	return(g);}/***********************************************************************/double aknint(double	xbar,int		in,int		im,double	x[10],double	y[10],double	t[81])/* *	AITKEN repeated interpolation *	 *	xbar	= abscissa at which interpolation is desired *	iabs(in)= no. of values in table *				if in.gt.0, chk ordering of x(i). *				if in.lt.0, skip preceeding test. *	im		= degree of approximating polynomial *	x		= vector of iabs(in) values of abscissa *	y		= vector of iabs(in) values of ordinate *	t		= temporary storage vector of 4*(m+1) locations)*/{	int		i,j,k,m,n,jj,kk;	int		mend;	double	s,z;	n = abs(in);	m = im;	if (m>=n) {		printf("aknint, WARNING -- order of interpolation too large\n");		m = n - 1;	}	k = n - 1;	if (n<2) {		printf("aknint n < 2, ybar returned as y[1]\n");		return(y[1]);	}	s = x[2]-x[1];	if (in>=0 && n!=2) {		for(i=3;i<=n;i++) {		/*	chk if order monotonic */			z = (x[i]-x[i-1]) * s;			if (z<=0.) {				printf("aknint x(i) not sequenced properly\n");				printf("aknint n.lt.2 ybar returned as y[1]\n");				return(y[1]);			}		}	}	if (s<0) {							/*	decreasing order */		for(j=1;j<=n;j++) { if (xbar>=x[j]) break; }		if (xbar<x[j]) { j = n; }	}	else {								/*	increasing order */		for(j=1;j<=n;j++) { if (xbar<=x[j]) break; }		if (xbar>x[j]) { j = n; }	}	k = m;	m = m+1;	j = j-m/2;	j = MAX(j,1);	j = MIN(j,n-k);	mend = j+k;	for(i=j;i<=mend;i++) {		kk = i - j + 1;		t[kk] = y[i];		t[kk+m] = x[i] - xbar;	}	for(i=1;i<=k;i++) {		kk = i + 1;		for(jj=kk;jj<=m;jj++) { t[jj] = (t[i]*t[jj+m]-t[jj]*t[i+m])/(x[jj+j-1]-x[i+j-1]); }	}	return(t[m]);}/***********************************************************************/void sort_fp(int n, double a[], double b[]){int		m,i,i1,j;double	x,y;	m = n - 1;	for(i=1;i<=m;i++) {		i1 = i + 1;		for(j=i1;j<=n;j++) {			if(a[j]<=a[i]) {				x = a[j];				y = a[i];				a[i] = x;				a[j] = y;				x = b[j];				y = b[i];				b[i] = x;				b[j] = y;			}		}	}}